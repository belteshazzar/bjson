<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Binary JSON with OPFS Demo</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
    }
    .container {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .error {
      background: #f8d7da;
      color: #721c24;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    .success {
      background: #d4edda;
      color: #155724;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    textarea {
      width: 100%;
      min-height: 200px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .output {
      background: #f8f9fa;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 400px;
      overflow-y: auto;
    }
    .info {
      background: #d1ecf1;
      color: #0c5460;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    input[type="text"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Binary JSON with OPFS Demo</h1>
  
  <div class="container">
    <div class="info">
      <strong>Note:</strong> File operations now use Web Workers for FileSystemSyncAccessHandle support.<br>
      All file I/O is handled asynchronously in a dedicated worker thread.<br>
      Supported browsers include Chrome 102+, Edge 102+, and Opera 88+.
    </div>
    <div class="error" id="workerWarning" style="display: none;">
      <strong>Warning:</strong> File operations are not working because Web Worker context is unavailable or an error occurred.
    </div>
  </div>

  <div class="container">
    <h2>File Operations (Requires Web Worker)</h2>
    
    <div>
      <label for="filename">Filename:</label>
      <input type="text" id="filename" value="test.bjson" placeholder="Enter filename">
    </div>

    <div>
      <label for="jsonInput">JSON Data to Write:</label>
      <textarea id="jsonInput" placeholder='Enter JSON data, e.g., {"name": "John", "age": 30}'>{
  "name": "Test Document",
  "id": ObjectId("507f1f77bcf86cd799439011"),
  "createdAt": Date("2023-01-15T12:30:45Z"),
  "dataPointer": Pointer(2048),
  "count": 42,
  "price": 99.99,
  "active": true,
  "tags": ["javascript", "binary", "json"],
  "metadata": {
    "created": 1234567890,
    "updated": null
  }
}</textarea>
    </div>

    <div class="controls">
      <button id="writeFileBtn">Write to File</button>
      <button id="readFileBtn">Read from File</button>
      <button id="appendToFileBtn">Append to File</button>
      <button id="scanFileBtn">Scan File (Read All Records)</button>
      <button id="deleteFileBtn">Delete File</button>
      <button id="checkFileExistsBtn">Check if File Exists</button>
    </div>

    <div id="message"></div>

    <div>
      <h3>Output:</h3>
      <div id="output" class="output">No output yet...</div>
    </div>
  </div>

  <div class="container">
    <h2>Encoding/Decoding Demo</h2>
    
    <div class="info">
      <strong>Supported special types:</strong><br>
      • <code>ObjectId("507f1f77bcf86cd799439011")</code> - MongoDB ObjectId<br>
      • <code>Date("2023-01-15T12:30:45Z")</code> - ISO date string<br>
      • <code>Pointer(2048)</code> - File offset pointer (non-negative 64-bit integer)
    </div>
    
    <div>
      <label for="encodeInput">Data to Encode:</label>
      <textarea id="encodeInput" placeholder='Enter JSON data to encode with optional ObjectId() and Date()'>{"test": "value", "number": 42, "created": Date("2023-01-15T12:30:45Z"), "_id": ObjectId("507f1f77bcf86cd799439011"), "offset": Pointer(1024)}</textarea>
    </div>

    <div class="controls">
      <button id="encodeBtn">Encode to Binary</button>
      <button id="decodeBtn">Decode from Binary</button>
    </div>

    <div id="encodeMessage"></div>

    <div>
      <h3>Binary Output (Hex):</h3>
      <div id="binaryOutput" class="output">No output yet...</div>
    </div>

    <div>
      <h3>Decoded Output (JSON):</h3>
      <div id="decodeOutput" class="output">No output yet...</div>
    </div>
  </div>

  <div class="container">
    <h2>Type Byte Reference</h2>
    <div class="output">
NULL:    0x00
FALSE:   0x01
TRUE:    0x02
INT:     0x03 (32-bit signed integer, 4 bytes, little-endian)
FLOAT:   0x04 (64-bit float, 8 bytes, little-endian)
STRING:  0x05 (length as 32-bit uint + UTF-8 bytes)
OID:     0x06 (MongoDB ObjectId, 12 bytes)
DATE:    0x07 (64-bit signed integer, milliseconds since epoch)
POINTER: 0x08 (64-bit non-negative integer, file offset)
ARRAY:   0x10 (length as 32-bit uint + elements)
OBJECT:  0x11 (num keys as 32-bit uint + key-value pairs)
    </div>
  </div>

  <script type="module">

    import { ObjectId, Pointer, encode, decode } from '/src/bjson.js';
    let currentBinary = null;
    
    // Initialize web worker for file operations
    const worker = new Worker('/dist/worker.js');
    let workerMessageId = 0;
    const workerPromises = new Map();
    
    worker.addEventListener('message', (event) => {
      const { id, result, error } = event.data;
      const promise = workerPromises.get(id);
      
      if (promise) {
        if (error) {
          promise.reject(new Error(error));
        } else {
          promise.resolve(result);
        }
        workerPromises.delete(id);
      }
    });
    
    worker.addEventListener('error', (event) => {
      console.error('Worker error:', event.message);
      document.getElementById('workerWarning').style.display = 'block';
    });
    
    function callWorker(operation, filename, data) {
      return new Promise((resolve, reject) => {
        const id = ++workerMessageId;
        workerPromises.set(id, { resolve, reject });
        
        worker.postMessage({ id, operation, filename, data });
      });
    }

    // Parse extended JSON with ObjectId() and Date() constructors
    function parseExtendedJSON(jsonString) {
      // Replace ObjectId("...") with a temporary marker
      const objectIdPattern = /ObjectId\("([a-fA-F0-9]{24})"\)/g;
      const objectIds = [];
      let objectIdIndex = 0;
      const jsonWithObjectIdMarkers = jsonString.replace(objectIdPattern, (match, hex) => {
        objectIds.push(hex);
        return `"__OBJECTID_${objectIdIndex++}__"`;
      });

      // Replace Date("...") with a temporary marker
      const datePattern = /Date\("([^"]+)"\)/g;
      const dates = [];
      let dateIndex = 0;
      const jsonWithDateMarkers = jsonWithObjectIdMarkers.replace(datePattern, (match, dateStr) => {
        dates.push(dateStr);
        return `"__DATE_${dateIndex++}__"`;
      });

      // Replace Pointer(...) with a temporary marker
      const pointerPattern = /Pointer\((\d+)\)/g;
      const pointers = [];
      let pointerIndex = 0;
      const jsonWithMarkers = jsonWithDateMarkers.replace(pointerPattern, (match, offset) => {
        pointers.push(parseInt(offset));
        return `"__POINTER_${pointerIndex++}__"`;
      });

      // Parse the JSON
      const data = JSON.parse(jsonWithMarkers);

      // Replace markers with actual objects
      function replaceMarkers(obj) {
        if (obj === null || typeof obj !== 'object') {
          return obj;
        }

        if (Array.isArray(obj)) {
          return obj.map(replaceMarkers);
        }

        const result = {};
        for (const key in obj) {
          const value = obj[key];
          if (typeof value === 'string') {
            const objectIdMatch = value.match(/^__OBJECTID_(\d+)__$/);
            if (objectIdMatch) {
              result[key] = new ObjectId(objectIds[parseInt(objectIdMatch[1])]);
              continue;
            }

            const dateMatch = value.match(/^__DATE_(\d+)__$/);
            if (dateMatch) {
              result[key] = new Date(dates[parseInt(dateMatch[1])]);
              continue;
            }

            const pointerMatch = value.match(/^__POINTER_(\d+)__$/);
            if (pointerMatch) {
              result[key] = new Pointer(pointers[parseInt(pointerMatch[1])]);
              continue;
            }
          }

          result[key] = replaceMarkers(value);
        }
        return result;
      }

      return replaceMarkers(data);
    }

    // Format output with custom serializer for ObjectId and Date
    function formatOutput(obj) {
      for (const key in obj) {
        const value = obj[key];
        if (value instanceof ObjectId) {
          obj[key] = `ObjectId("${value.toString()}")`
        } else if (value instanceof Date) {
          obj[key] = `Date("${value.toISOString()}")`
        } else if (value instanceof Pointer) {
          obj[key] = `Pointer(${value.valueOf()})`
        }
      }

      return JSON.stringify(obj, null, 2);
    }

    function showMessage(elementId, message, type = 'success') {
      const element = document.getElementById(elementId);
      element.innerHTML = `<div class="${type}">${message}</div>`;
      setTimeout(() => {
        element.innerHTML = '';
      }, 5000);
    }

    async function writeFile() {
      try {
        const filename = document.getElementById('filename').value || 'demo.bjson';
        const jsonInput = document.getElementById('jsonInput').value;
        const data = parseExtendedJSON(jsonInput);
        const binary = encode(data);
        
        await callWorker('write', filename, Array.from(binary));
        showMessage('message', `Successfully wrote ${binary.length} bytes to ${filename}`);
        document.getElementById('output').textContent = 'Data written to file successfully!';
      } catch (error) {
        showMessage('message', `Error: ${error.message}`, 'error');
        console.error(error);
      }
    }

    document.getElementById('writeFileBtn').addEventListener('click', writeFile);

    async function readFile() {
      try {
        const filename = document.getElementById('filename').value || 'demo.bjson';
        const data = await callWorker('read', filename);
        
        showMessage('message', `Successfully read data from ${filename}`);
        document.getElementById('output').textContent = JSON.stringify(data, null, 2);
      } catch (error) {
        showMessage('message', `Error: ${error.message}`, 'error');
        console.error(error);
      }
    }

    document.getElementById('readFileBtn').addEventListener('click', readFile);

    async function appendToFile() {
      try {
        const filename = document.getElementById('filename').value || 'demo.bjson';
        const jsonInput = document.getElementById('jsonInput').value;
        const data = parseExtendedJSON(jsonInput);
        const binary = encode(data);
        
        await callWorker('append', filename, Array.from(binary));
        showMessage('message', `Successfully appended ${binary.length} bytes to ${filename}`);
        document.getElementById('output').textContent = 'Data appended to file successfully!';
      } catch (error) {
        showMessage('message', `Error: ${error.message}`, 'error');
        console.error(error);
      }
    }

    document.getElementById('appendToFileBtn').addEventListener('click', appendToFile);

    async function scanFile() {
      try {
        const filename = document.getElementById('filename').value || 'demo.bjson';
        const records = await callWorker('scan', filename);
        
        showMessage('message', `Successfully scanned ${records.length} record(s) from ${filename}`);
        document.getElementById('output').textContent = JSON.stringify(records, null, 2);
      } catch (error) {
        showMessage('message', `Error: ${error.message}`, 'error');
        console.error(error);
      }
    }

    document.getElementById('scanFileBtn').addEventListener('click', scanFile);

    async function deleteFile() {
      try {
        const filename = document.getElementById('filename').value || 'demo.bjson';
        await callWorker('delete', filename);
        
        showMessage('message', `Successfully deleted ${filename}`);
        document.getElementById('output').textContent = 'File deleted successfully!';
      } catch (error) {
        showMessage('message', `Error: ${error.message}`, 'error');
        console.error(error);
      }
    }

    document.getElementById('deleteFileBtn').addEventListener('click', deleteFile);

    async function checkFileExists() {
      try {
        const filename = document.getElementById('filename').value || 'demo.bjson';
        const exists = await callWorker('exists', filename);
        
        showMessage('message', `File ${filename} ${exists ? 'exists' : 'does not exist'}`);
        document.getElementById('output').textContent = `File exists: ${exists}`;
      } catch (error) {
        showMessage('message', `Error: ${error.message}`, 'error');
        console.error(error);
      }
    }

    document.getElementById('checkFileExistsBtn').addEventListener('click', checkFileExists);

    function testEncode() {
      try {
        const input = document.getElementById('encodeInput').value;
        const data = parseExtendedJSON(input);
        
        currentBinary = encode(data);
        
        // Convert to hex string for display
        const hexString = Array.from(currentBinary)
          .map(b => b.toString(16).padStart(2, '0'))
          .join(' ');
        
        document.getElementById('binaryOutput').textContent = 
          `Length: ${currentBinary.length} bytes\n\nHex:\n${hexString}`;
        
        showMessage('encodeMessage', 'Successfully encoded data to binary');
      } catch (error) {
        showMessage('encodeMessage', `Error: ${error.message}`, 'error');
        console.error(error);
      }
    }

    document.getElementById('encodeBtn').addEventListener('click', testEncode);

    function testDecode() {
      try {
        if (!currentBinary) {
          showMessage('encodeMessage', 'Please encode data first', 'error');
          return;
        }
        
        const decoded = decode(currentBinary);
        document.getElementById('decodeOutput').textContent = formatOutput(decoded);
        
        showMessage('encodeMessage', 'Successfully decoded binary data');
      } catch (error) {
        showMessage('encodeMessage', `Error: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    document.getElementById('decodeBtn').addEventListener('click', testDecode);
    
    // Check OPFS support on load
    window.addEventListener('load', () => {
      if (!navigator.storage || !navigator.storage.getDirectory) {
        showMessage('message', 
          'Origin Private File System (OPFS) is not supported in this browser. Please use Chrome 102+, Edge 102+, or Opera 88+.', 
          'error'
        );
      }
    });
  </script>
</body>
</html>
